import fs from 'fs';
import dotenv from 'dotenv';
import axios from 'axios';
import Web3 from 'web3';

// åŠ è½½ç¯å¢ƒå˜é‡ï¼ˆä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼‰
dotenv.config({ path: './config.env' });

// è®¾ç½®è´¦å·å’Œç§é’¥
const account = '0x43be9AFA6B131A89B0771Aa9365A8967aDa3b06f';  
const privateKey = process.env.PRIVATE_KEY;
const web3 = new Web3(new Web3.providers.HttpProvider('https://bsc-dataseed.binance.org/'));

// åŠ è½½ ABI æ–‡ä»¶ï¼ˆæ”¹ä¸ºç›¸å¯¹è·¯å¾„ï¼‰
const pancakeAbi = JSON.parse(fs.readFileSync('./PancakeSwapABI.json', 'utf-8'));
const erc20Abi = JSON.parse(fs.readFileSync('./ERC20ABI.json', 'utf-8'));

// PancakeSwap è·¯ç”±åœ°å€å’Œ WBNB åœ°å€
const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';  
const WBNB = '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'.toLowerCase(); 
const pancakeRouter = new web3.eth.Contract(pancakeAbi, PANCAKE_ROUTER);

// æ£€æŸ¥ä½™é¢
async function checkBalance() {
    const balance = await web3.eth.getBalance(account);
    console.log(`ğŸ’° å½“å‰é’±åŒ…ä½™é¢: ${web3.utils.fromWei(balance, 'ether')} BNB`);

    const wbnbBalance = await getTokenBalance(WBNB);
    console.log(`ğŸ’° å½“å‰é’±åŒ…WBNBä½™é¢: ${web3.utils.fromWei(wbnbBalance, 'ether')} WBNB`);
}

// è·å–æŸä¸ªä»£å¸ä½™é¢
async function getTokenBalance(tokenAddress) {
    const token = new web3.eth.Contract(erc20Abi, tokenAddress);
    const balance = await token.methods.balanceOf(account).call();
    return balance;
}

// è·å–å½“å‰ Gas ä»·æ ¼
async function getGasPrice() {
    try {
        const response = await axios.get('https://api.bscscan.com/api', {
            params: {
                module: 'gastracker',
                action: 'gasoracle',
                apikey: process.env.BSCSCAN_API_KEY
            }
        });
        const fastGasPrice = response.data.result.FastGasPrice;
        if (!fastGasPrice) {
            throw new Error('æ— æ³•è·å–æœ‰æ•ˆçš„ Gas ä»·æ ¼');
        }
        return web3.utils.toWei(fastGasPrice.toString(), 'gwei');
    } catch (err) {
        console.error('è·å– Gas ä»·æ ¼å¤±è´¥:', err);
        return web3.utils.toWei('5', 'gwei'); // é»˜è®¤å€¼
    }
}

// è·å–ä»£å¸ç¨ç‡
async function getTaxPercentage(tokenAddress) {
    try {
        const token = new web3.eth.Contract(erc20Abi, tokenAddress);
        const code = await web3.eth.getCode(tokenAddress);
        if (code === '0x' || tokenAddress === '0x0000000000000000000000000000000000000000') {
            console.log(`âš ï¸ æ— æ•ˆçš„ERC-20åˆçº¦åœ°å€: ${tokenAddress}`);
            return 0; 
        }

        const taxPercentage = await token.methods.taxPercentage().call();
        return parseInt(taxPercentage, 10);
    } catch (err) {
        console.error('è·å–ç¨ç‡å¤±è´¥:', err);
        return 0; 
    }
}

// æŒç»­è½®è¯¢åŒºå—
async function pollBlocks() {
    await checkBalance();
    let latestBlock = await web3.eth.getBlockNumber();
    console.log(`å½“å‰æœ€æ–°åŒºå—: ${latestBlock}`);

    setInterval(async () => {
        try {
            let newBlock = await web3.eth.getBlockNumber();
            if (newBlock > latestBlock) {
                console.log(`æ£€æµ‹åˆ°æ–°åŒºå—: ${newBlock}`);
                latestBlock = newBlock;
                await processBlock(newBlock);
            }
        } catch (err) {
            console.error("RPC è¿æ¥å¤±è´¥ï¼Œå°è¯•åˆ‡æ¢èŠ‚ç‚¹...", err);
        }
    }, 2000);
}

async function processBlock(blockNumber) {
    try {
        const block = await web3.eth.getBlock(blockNumber, true);
        if (!block || !block.transactions) return;

        for (const tx of block.transactions) {
            if (tx.to && tx.to.toLowerCase() === PANCAKE_ROUTER.toLowerCase()) {
                console.log(`å‘ç° PancakeSwap äº¤æ˜“: ${tx.hash}`);
                await analyzeTransaction(tx);
            }
        }
    } catch (err) {
        console.error("è·å–åŒºå—å¤±è´¥:", err);
    }
}

// è§£æäº¤æ˜“ï¼Œè¯†åˆ«å¹¶è¿›è¡Œä¸‰æ˜æ²»æ”»å‡»
async function analyzeTransaction(tx) {
    try {
        const tokenAddress = '0x' + tx.input.slice(34, 74); 
        console.log(`æ£€æµ‹åˆ°ä»£å¸: ${tokenAddress}`);
        
        const code = await web3.eth.getCode(tokenAddress);
        if (code === '0x' || tokenAddress === '0x0000000000000000000000000000000000000000') {
            console.log(`âš ï¸ æ— æ•ˆçš„ERC-20åˆçº¦åœ°å€: ${tokenAddress}`);
            return;
        }

        const tax = await getTaxPercentage(tokenAddress);
        if (tax > 5) {
            console.log(`âš ï¸ é«˜ç¨æ”¶ä»£å¸ (${tax}%)ï¼Œè·³è¿‡å¤¹å•`);
            return;
        }

        const wbnbBalance = await getTokenBalance(WBNB);
        const canUseBNB = await canUseBNBForTransaction(tokenAddress);
        const tokenAmount = getRandomAmountBasedOnBNBValue();

        if (wbnbBalance > 0 || canUseBNB) {
            await executeSandwichAttack(tokenAddress, tx, tokenAmount);
        } else {
            console.log("æ²¡æœ‰è¶³å¤Ÿçš„WBNBæˆ–è€…åˆçº¦ä¸æ”¯æŒç›´æ¥ä½¿ç”¨BNBè¿›è¡Œäº¤æ˜“ï¼Œè·³è¿‡æ­¤æ¬¡äº¤æ˜“ã€‚");
        }
    } catch (err) {
        console.error("è§£æäº¤æ˜“å¤±è´¥:", err);
    }
}

async function canUseBNBForTransaction(tokenAddress) {
    return true; 
}

function getRandomAmountBasedOnBNBValue() {
    const minAmount = 0.001; 
    const maxAmount = 0.035; 
    return (Math.random() * (maxAmount - minAmount) + minAmount).toFixed(5); 
}

async function executeSandwichAttack(tokenAddress, tx, tokenAmount) {
    console.log(`âœ… è¿›è¡Œä¸‰æ˜æ²»æ”»å‡» ${tokenAddress}`);
    
    const gasPrice = await getGasPrice();
    const adjustedGasPrice = web3.utils.toWei((parseFloat(gasPrice) * 1.5).toString(), 'gwei');

    const buyTx = {
        from: account,
        to: PANCAKE_ROUTER,
        gasLimit: 300000,
        gasPrice: adjustedGasPrice,
        value: web3.utils.toWei(tokenAmount, 'ether'),
        data: pancakeRouter.methods.swapExactETHForTokensSupportingFeeOnTransferTokens(
            0,
            [WBNB, tokenAddress],
            account,
            Math.floor(Date.now() / 1000) + 300 
        ).encodeABI()
    };

    try {
        const signedTx = await web3.eth.accounts.signTransaction(buyTx, privateKey);
        const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
        console.log(`äº¤æ˜“æˆåŠŸ: ${receipt.transactionHash}`);
    } catch (err) {
        console.error("äº¤æ˜“å¤±è´¥:", err);
    }
}

pollBlocks();  
